<?php
declare(strict_types=1);

namespace PITS\AiSemanticSearch\Service;

use TYPO3\CMS\Core\Configuration\ExtensionConfiguration;
use TYPO3\CMS\Core\SingletonInterface;
use TYPO3\CMS\Core\Utility\GeneralUtility;

class VectorService implements SingletonInterface
{
    private array $config;

    public function __construct()
    {
        $this->config = GeneralUtility::makeInstance(ExtensionConfiguration::class)
            ->get('ai_semantic_search');
    }

    public function generateEmbedding(string $text): array
    {
        $apiKey = $this->config['openai_api_key'] ?? '';
        if (empty($apiKey)) {
            throw new \Exception('OpenAI API key not configured');
        }

        // Clean and prepare text
        $text = $this->preprocessText($text);

        $data = [
            'model' => $this->config['embedding_model'] ?? 'text-embedding-3-small',
            'input' => $text,
            'encoding_format' => 'float'
        ];

        $context = stream_context_create([
            'http' => [
                'method' => 'POST',
                'header' => [
                    'Content-Type: application/json',
                    'Authorization: Bearer ' . $apiKey
                ],
                'content' => json_encode($data)
            ]
        ]);

        $response = file_get_contents('https://api.openai.com/v1/embeddings', false, $context);
        
        if ($response === false) {
            throw new \Exception('Failed to generate embedding');
        }

        $result = json_decode($response, true);
        
        if (isset($result['error'])) {
            throw new \Exception('OpenAI API Error: ' . $result['error']['message']);
        }

        $embedding = $result['data'][0]['embedding'];
        
        // Normalize the vector (even though OpenAI embeddings are already normalized)
        return $this->normalizeVector($embedding);
    }

    private function preprocessText(string $text): string
    {
        // Remove HTML tags
        $text = strip_tags($text);
        
        // Remove extra whitespace
        $text = preg_replace('/\s+/', ' ', $text);
        
        // Trim and limit length (OpenAI has token limits)
        $text = trim($text);
        
        // Truncate if too long (approximately 8000 tokens for text-embedding-3-small)
        if (strlen($text) > 32000) {
            $text = substr($text, 0, 32000);
        }
        
        return $text;
    }

    private function normalizeVector(array $vector): array
    {
        // Calculate L2 norm
        $norm = sqrt(array_sum(array_map(function($x) { return $x * $x; }, $vector)));
        
        // Avoid division by zero
        if ($norm == 0) {
            return $vector;
        }
        
        // Normalize each component
        return array_map(function($x) use ($norm) { return $x / $norm; }, $vector);
    }

    public function calculateCosineSimilarity(array $vector1, array $vector2): float
    {
        // Ensure both vectors are normalized
        $vector1 = $this->normalizeVector($vector1);
        $vector2 = $this->normalizeVector($vector2);
        
        // Calculate dot product (cosine similarity for normalized vectors)
        $dotProduct = 0;
        for ($i = 0; $i < count($vector1); $i++) {
            $dotProduct += $vector1[$i] * $vector2[$i];
        }
        
        return $dotProduct;
    }

    public function getEmbeddingDimension(): int
    {
        $model = $this->config['embedding_model'] ?? 'text-embedding-3-small';
        
        return match($model) {
            'text-embedding-3-small' => 1536,
            'text-embedding-3-large' => 3072,
            'text-embedding-ada-002' => 1536,
            default => 1536
        };
    }

    public function formatVectorForPostgreSQL(array $vector): string
    {
        return '[' . implode(',', $vector) . ']';
    }
}
